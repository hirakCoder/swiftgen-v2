<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwiftGen AI - Next-Gen iOS App Generator</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23667eea' stroke-width='2'%3E%3Cpath d='M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-swift.min.js"></script>
    <!-- app.js disabled - using embedded SwiftGenApp implementation -->
    <!-- <script src="app.js?v=1.1" defer></script> -->
    <style>
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* Typing indicator animation */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .typing-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #9CA3AF;
            animation: typing-dot 1.4s infinite ease-in-out;
        }
        
        .typing-indicator span:nth-child(1) {
            animation-delay: -0.32s;
        }
        
        .typing-indicator span:nth-child(2) {
            animation-delay: -0.16s;
        }
        
        @keyframes typing-dot {
            0%, 80%, 100% {
                opacity: 0.4;
                transform: scale(0.8);
            }
            40% {
                opacity: 1;
                transform: scale(1);
            }
        }
        .glass-morphism {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }
        .typing-indicator {
            display: inline-flex;
            align-items: center;
        }
        .typing-indicator span {
            height: 8px;
            width: 8px;
            background-color: #667eea;
            border-radius: 50%;
            display: inline-block;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }
        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }
        .chat-message {
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        pre[class*="language-"] {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 1rem;
            margin: 0;
        }
        code[class*="language-"] {
            font-family: 'Fira Code', monospace;
        }
        .progress-stage {
            transition: all 0.3s ease;
        }
        .progress-stage.active {
            transform: scale(1.1);
        }
        .progress-stage.complete svg {
            color: #10b981;
        }
        /* Hide scrollbar for chat but keep functionality */
        .chat-container::-webkit-scrollbar {
            width: 6px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        .chat-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        /* Intelligent message styles */
        .intelligent-message {
            position: fixed;
            top: 80px;
            right: 20px;
            max-width: 400px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideInRight 0.5s ease-out;
            transition: all 0.3s ease;
        }
        .intelligent-message.motivational {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
            border-color: rgba(16, 185, 129, 0.3);
        }
        .intelligent-message .message-content {
            color: #e5e7eb;
            font-size: 15px;
            line-height: 1.5;
            margin: 0;
        }
        .intelligent-message .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            font-size: 18px;
            padding: 4px;
            transition: color 0.2s;
        }
        .intelligent-message .close-btn:hover {
            color: rgba(255, 255, 255, 0.8);
        }
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.9);
            }
        }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 font-sans min-h-screen flex flex-col">
<!-- Header -->
<header class="glass-morphism border-b border-gray-800 sticky top-0 z-50">
    <div class="max-w-7xl mx-auto px-6 py-4">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-3">
                <div class="w-10 h-10 bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg flex items-center justify-center">
                    <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path>
                    </svg>
                </div>
                <div>
                    <h1 class="text-2xl font-bold gradient-text">SwiftGen AI</h1>
                    <p class="text-xs text-gray-400">Next-Generation iOS App Creator</p>
                </div>
            </div>
            <div class="flex items-center space-x-4">
                <button id="advancedToggle" class="text-sm text-gray-400 hover:text-gray-200 transition-colors">
                    <i class="fas fa-cog mr-1"></i> Advanced Options
                </button>
                <div class="h-6 w-px bg-gray-700"></div>
                <span class="text-sm text-gray-400">
                        <i class="fas fa-circle text-green-400 text-xs mr-1"></i> System Ready
                    </span>
            </div>
        </div>
    </div>
</header>

<!-- Advanced Options Panel (Hidden by default) -->
<div id="advancedPanel" class="hidden glass-morphism border-b border-gray-800">
    <div class="max-w-7xl mx-auto px-6 py-4">
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
                <label class="block text-sm font-medium text-gray-300 mb-2">Target iOS Version</label>
                <select id="iosVersion" class="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:border-blue-500">
                    <option value="17.0" selected>iOS 17.0+ (Latest)</option>
                    <option value="16.0">iOS 16.0+</option>
                    <option value="15.0">iOS 15.0+</option>
                </select>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-300 mb-2">App Template</label>
                <select id="appTemplate" class="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:border-blue-500">
                    <option value="auto" selected>Auto-detect</option>
                    <option value="single-view">Single View App</option>
                    <option value="tab-based">Tab-based App</option>
                    <option value="navigation">Navigation App</option>
                </select>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-300 mb-2">Features</label>
                <div class="space-y-2">
                    <label class="flex items-center">
                        <input type="checkbox" id="useSwiftUI" checked class="mr-2 text-blue-500">
                        <span class="text-sm">Use SwiftUI</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="includeTests" class="mr-2 text-blue-500">
                        <span class="text-sm">Include Unit Tests</span>
                    </label>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Main Content -->
<main class="flex-1 flex">
    <div class="max-w-7xl mx-auto w-full flex flex-col lg:flex-row gap-6 p-6">
        <!-- Chat Section -->
        <div class="flex-1 flex flex-col">
            <div class="glass-morphism rounded-2xl flex flex-col h-full">
                <!-- Chat Header -->
                <div class="px-6 py-4 border-b border-gray-800">
                    <h2 class="text-lg font-semibold flex items-center">
                        <i class="fas fa-comments mr-2 text-blue-400"></i>
                        App Creator Chat
                    </h2>
                </div>

                <!-- Chat Messages -->
                <div id="chatMessages" class="flex-1 overflow-y-auto p-6 space-y-4 chat-container">
                    <div class="chat-message">
                        <div class="flex items-start space-x-3">
                            <div class="w-8 h-8 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center flex-shrink-0">
                                <i class="fas fa-robot text-white text-sm"></i>
                            </div>
                            <div class="flex-1">
                                <p class="text-sm text-gray-300">
                                    Hello! I'm SwiftGen AI. I can create any iOS app you can imagine. Just describe what you want to build, and I'll generate the complete Swift code for you.
                                </p>
                                <p class="text-sm text-gray-400 mt-2">
                                    For example: "Create a todo list app with categories" or "Build a weather app with current conditions and forecast"
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Status Panel -->
                <div id="statusPanel" class="hidden px-6 py-4 border-t border-gray-800 bg-gray-900/50">
                    <div class="flex items-center justify-between mb-3">
                        <h3 id="progressTitle" class="text-sm font-medium text-gray-300">
                            <i class="fas fa-tasks mr-2"></i>Generation Progress
                        </h3>
                        <div class="flex items-center gap-4">
                            <span id="generationTimer" class="text-xs text-gray-400">
                                <i class="fas fa-clock mr-1"></i>
                                <span id="timerDisplay">0:00</span>
                            </span>
                            <button id="toggleDetails" class="text-xs text-gray-400 hover:text-gray-200">
                                <i class="fas fa-chevron-down mr-1"></i>Details
                            </button>
                        </div>
                    </div>

                    <!-- Current Status Message -->
                    <div id="currentStatusMessage" class="mb-3 px-4 py-3 bg-gray-800/50 rounded-lg border border-gray-700">
                        <p class="text-sm text-gray-300 font-medium">
                            <i class="fas fa-circle-notch fa-spin mr-2 text-xs"></i>
                            <span id="progressText">Initializing...</span>
                        </p>
                    </div>
                    
                    <!-- Progress Stages -->
                    <div class="flex items-center justify-between mb-3">
                        <div class="text-center">
                            <div id="stage-design" class="w-8 h-8 mx-auto mb-1 bg-gray-800 rounded-full flex items-center justify-center progress-stage">
                                <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z"></path>
                                </svg>
                            </div>
                            <p class="text-xs text-gray-500">Design</p>
                        </div>
                        <div class="text-center">
                            <div id="stage-implement" class="w-8 h-8 mx-auto mb-1 bg-gray-800 rounded-full flex items-center justify-center progress-stage">
                                <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path>
                                </svg>
                            </div>
                            <p class="text-xs text-gray-500">Code</p>
                        </div>
                        <div class="text-center">
                            <div id="stage-validate" class="w-8 h-8 mx-auto mb-1 bg-gray-800 rounded-full flex items-center justify-center progress-stage">
                                <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                            </div>
                            <p class="text-xs text-gray-500">Validate</p>
                        </div>
                        <div class="text-center">
                            <div id="stage-build" class="w-8 h-8 mx-auto mb-1 bg-gray-800 rounded-full flex items-center justify-center progress-stage">
                                <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path>
                                </svg>
                            </div>
                            <p class="text-xs text-gray-500">Build</p>
                        </div>
                        <div class="text-center">
                            <div id="stage-fix" class="w-8 h-8 mx-auto mb-1 bg-gray-800 rounded-full flex items-center justify-center progress-stage">
                                <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                </svg>
                            </div>
                            <p class="text-xs text-gray-500">Fix</p>
                        </div>
                        <div class="text-center">
                            <div id="stage-launch" class="w-8 h-8 mx-auto mb-1 bg-gray-800 rounded-full flex items-center justify-center progress-stage">
                                <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                                </svg>
                            </div>
                            <p class="text-xs text-gray-500">Launch</p>
                        </div>
                    </div>

                    <!-- Detailed Messages (Initially Hidden) -->
                    <div id="detailsPanel" class="hidden border-t border-gray-700 pt-3 mt-3">
                        <div id="statusDetails" class="space-y-2 max-h-40 overflow-y-auto text-xs">
                            <!-- Status messages will appear here -->
                        </div>
                    </div>

                    <!-- Error Section (Initially Hidden) -->
                    <div id="errorSection" class="hidden mt-3 p-3 bg-red-500/10 border border-red-500/30 rounded-lg">
                        <div class="flex items-start space-x-2">
                            <svg class="w-5 h-5 text-red-400 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <div class="flex-1">
                                <p class="font-medium text-red-400 mb-1">Build Failed</p>
                                <div id="errorList" class="space-y-1 text-sm text-red-300">
                                    <!-- Errors will appear here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Chat Input -->
                <div class="px-6 py-4 border-t border-gray-700 bg-gray-900/50">
                    <form id="chatForm" class="flex items-end space-x-3">
                        <div class="flex-1">
                                <textarea
                                        id="chatInput"
                                        rows="1"
                                        class="w-full px-4 py-3 bg-gray-800 border border-gray-700 rounded-xl focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 resize-none text-gray-100"
                                        placeholder="Describe your app or request changes..."
                                        style="min-height: 48px; max-height: 120px;"
                                ></textarea>
                        </div>
                        <button
                                type="submit"
                                id="sendBtn"
                                class="px-5 py-3 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white rounded-xl font-medium transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
                        >
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                            </svg>
                        </button>
                    </form>
                </div>
            </div>
        </div>

        <!-- Code Preview Section -->
        <div class="lg:w-[500px] flex flex-col">
            <div class="glass-morphism rounded-2xl flex flex-col h-full">
                <!-- Code Header -->
                <div class="px-6 py-4 border-b border-gray-800 flex items-center justify-between">
                    <h2 class="text-lg font-semibold flex items-center">
                        <i class="fas fa-code mr-2 text-purple-400"></i>
                        Generated Code
                    </h2>
                    <div id="codeActions" class="hidden space-x-2">
                        <button id="copyCode" class="text-sm text-gray-400 hover:text-gray-200 transition-colors">
                            <i class="fas fa-copy mr-1"></i>Copy
                        </button>
                        <button id="downloadCode" class="text-sm text-gray-400 hover:text-gray-200 transition-colors">
                            <i class="fas fa-download mr-1"></i>Download
                        </button>
                    </div>
                </div>

                <!-- Code Display -->
                <div class="flex-1 overflow-hidden flex flex-col">
                    <!-- File Tabs -->
                    <div id="fileTabs" class="hidden px-6 pt-4 pb-2 border-b border-gray-800">
                        <div id="fileTabsContainer" class="flex space-x-1 overflow-x-auto">
                            <!-- File tabs will be inserted here -->
                        </div>
                    </div>

                    <!-- Code Content -->
                    <div id="codeDisplay" class="hidden flex-1 overflow-auto">
                        <pre class="h-full"><code id="codeContent" class="language-swift"></code></pre>
                    </div>

                    <!-- No Code Message -->
                    <div id="noCodeMessage" class="flex-1 flex items-center justify-center p-8">
                        <div class="text-center">
                            <div class="w-16 h-16 mx-auto mb-4 bg-gray-800 rounded-full flex items-center justify-center">
                                <i class="fas fa-code text-gray-600 text-2xl"></i>
                            </div>
                            <p class="text-gray-400 mb-2">No code generated yet</p>
                            <p class="text-sm text-gray-500">Describe your app idea to see the magic happen!</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</main>

<!-- Success Modal -->
<div id="successModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="glass-morphism rounded-2xl p-8 max-w-md mx-4 transform transition-all">
        <div class="text-center">
            <div class="w-20 h-20 mx-auto mb-4 bg-gradient-to-r from-green-400 to-blue-500 rounded-full flex items-center justify-center">
                <i class="fas fa-check text-white text-3xl"></i>
            </div>
            <h3 id="modalTitle" class="text-2xl font-bold mb-2">App Created Successfully!</h3>
            <p id="modalSubtitle" class="text-gray-400 mb-2">Your app is now running in the iOS Simulator</p>
            <div id="modalLLMInfo" class="flex items-center justify-center text-sm text-gray-400 mb-6">
                <i class="fas fa-robot mr-2 text-gray-500"></i>
                <span id="llmProvider" class="font-medium">Unknown</span>
            </div>
            <button id="closeModal" class="px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-lg font-medium hover:from-blue-600 hover:to-purple-700 transition-all">
                Continue Building
            </button>
        </div>
    </div>
</div>

<script>
    // Global context storage for intelligent responses
    const project_contexts = {};
    
    class SwiftGenApp {
        constructor() {
            this.ws = null;
            this.currentProjectId = null;
            this.isGenerating = false;
            this.generatedFiles = [];
            this.currentFileIndex = 0;
            this.lastAction = null; // Track last action for context
            this.initializeElements();
            this.setupEventListeners();
            // Don't setup WebSocket on init - wait for project creation
        }

        initializeElements() {
            // Chat elements
            this.chatMessages = document.getElementById('chatMessages');
            this.chatInput = document.getElementById('chatInput');
            this.chatForm = document.getElementById('chatForm');
            this.sendBtn = document.getElementById('sendBtn');

            // Status elements
            this.statusPanel = document.getElementById('statusPanel');
            this.statusDetails = document.getElementById('statusDetails');
            this.errorSection = document.getElementById('errorSection');
            this.errorList = document.getElementById('errorList');
            this.detailsPanel = document.getElementById('detailsPanel');

            // Code display elements
            this.codeDisplay = document.getElementById('codeDisplay');
            this.codeContent = document.getElementById('codeContent');
            this.noCodeMessage = document.getElementById('noCodeMessage');
            this.fileTabs = document.getElementById('fileTabs');
            this.fileTabsContainer = document.getElementById('fileTabsContainer');
            this.codeActions = document.getElementById('codeActions');

            // Advanced options
            this.advancedToggle = document.getElementById('advancedToggle');
            this.advancedPanel = document.getElementById('advancedPanel');

            // Modal
            this.successModal = document.getElementById('successModal');
            this.closeModal = document.getElementById('closeModal');

            // Details toggle
            this.toggleDetails = document.getElementById('toggleDetails');
        }

        setupEventListeners() {
            // Chat form submission
            this.chatForm.addEventListener('submit', (e) => {
                e.preventDefault();
                this.handleSubmit();
            });

            // Auto-resize textarea
            this.chatInput.addEventListener('input', () => {
                this.chatInput.style.height = 'auto';
                this.chatInput.style.height = this.chatInput.scrollHeight + 'px';
            });

            // Advanced options toggle
            this.advancedToggle.addEventListener('click', () => {
                this.advancedPanel.classList.toggle('hidden');
            });

            // Details toggle
            this.toggleDetails.addEventListener('click', () => {
                this.detailsPanel.classList.toggle('hidden');
                const icon = this.toggleDetails.querySelector('i');
                icon.classList.toggle('fa-chevron-down');
                icon.classList.toggle('fa-chevron-up');
            });

            // Modal close
            this.closeModal.addEventListener('click', () => {
                this.successModal.classList.add('hidden');
            });

            // Code actions
            document.getElementById('copyCode').addEventListener('click', () => {
                this.copyCurrentCode();
            });

            document.getElementById('downloadCode').addEventListener('click', () => {
                this.downloadCurrentCode();
            });
        }

        setupWebSocket(projectId = null) {
            // Don't create WebSocket without a project ID
            if (!projectId && !this.currentProjectId) {
                console.log('No project ID available for WebSocket connection');
                return;
            }
            
            // Use provided projectId or existing currentProjectId
            const activeProjectId = projectId || this.currentProjectId;
            
            // Close existing WebSocket if any
            if (this.ws) {
                this.ws.close();
            }
            
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws/${activeProjectId}`;

            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                console.log(`WebSocket connected for project: ${activeProjectId}`);
                // Don't show connection message - it's confusing for users
            };

            this.ws.onmessage = (event) => {
                try {
                    // Try to parse as JSON
                    const data = JSON.parse(event.data);
                    this.handleWebSocketMessage(data);
                } catch (e) {
                    // If not JSON, it might be a plain text log message
                    // console.log('[WS] Received non-JSON message:', event.data);
                    // Optionally show as a status update if it looks like a build log
                    if (event.data.includes('[BUILD]') || event.data.includes('[SIMULATOR]')) {
                        this.updateStatus(event.data.replace(/\[.*?\]\s*/, ''), 'building');
                    }
                }
            };

            // Initialize reconnection parameters if not set
            if (!this.reconnectDelay) {
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.reconnectAttempts = 0;
            }
            
            this.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                // Error often precedes close event
            };
            
            this.ws.onclose = (event) => {
                console.log('WebSocket disconnected', event.code, event.reason);
                // Only reconnect if we still have a project ID AND it was an abnormal closure
                // Code 1000 = normal closure, 1001 = going away
                if (this.currentProjectId && event.code !== 1000 && event.code !== 1001) {
                    this.handleReconnect();
                }
            };
        }

        handleReconnect() {
            // Exponential backoff for reconnection
            const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts), this.maxReconnectDelay);
            this.reconnectAttempts++;
            
            console.log(`Will reconnect in ${delay/1000} seconds... (attempt ${this.reconnectAttempts})`);
            
            setTimeout(() => {
                if (this.currentProjectId) {
                    console.log('Attempting to reconnect WebSocket...');
                    this.setupWebSocket(this.currentProjectId);
                    
                    // Reset delay on successful connection
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.reconnectDelay = 1000;
                        this.reconnectAttempts = 0;
                    }
                }
            }, delay);
        }

        handleWebSocketMessage(data) {
            // console.log('[WS] Received message:', data);
            
            // Store currentProjectId when we receive it
            if (!this.currentProjectId && data.project_id) {
                this.currentProjectId = data.project_id;
                // console.log('[WS] Set currentProjectId:', this.currentProjectId);
            }
            
            if (data.project_id && this.currentProjectId && data.project_id !== this.currentProjectId) {
                // console.log('[WS] Ignoring message for different project');
                return;
            }

            switch (data.type) {
                case 'status':
                    // console.log('[WS] Status update received:', {
                    //     message: data.message,
                    //     status: data.status,
                    //     timestamp: new Date().toISOString()
                    // });
                    this.updateStatus(data.message, data.status);
                    
                    // Remove typing indicator on first status update during generation
                    if (!this.currentProjectId || this.isGenerating) {
                        // console.log('[WS] Removing typing indicator due to status update');
                        this.removeTypingIndicator();
                    }
                    
                    // Map backend status to UI stages
                    const stageMapping = {
                        'initializing': 'design',
                        'analyzing': 'design',
                        'generating': 'implement',
                        'generated': 'validate',
                        'validating': 'validate',
                        'healing': 'fix',
                        'creating': 'implement',
                        'building': 'build',
                        'updating': 'implement',
                        'rebuilding': 'build'
                    };
                    
                    if (stageMapping[data.status]) {
                        this.updateStatusStage(stageMapping[data.status], 'active');
                        
                        // Mark previous stages as complete
                        const allStages = ['design', 'implement', 'validate', 'build', 'fix', 'launch'];
                        const currentIndex = allStages.indexOf(stageMapping[data.status]);
                        for (let i = 0; i < currentIndex; i++) {
                            this.updateStatusStage(allStages[i], 'complete');
                        }
                    }
                    break;
                case 'stage_update':
                    this.updateStatusStage(data.stage, data.status);
                    break;
                case 'error':
                    console.error('[WS] Error:', data.message);  // Keep error logs
                    this.showError(data.message, data.details);
                    break;
                case 'complete':
                    // console.log('[WS] Generation complete - stopping timer and updating UI');
                    // Store features for context-aware responses
                    if (data.features) {
                        window.lastGeneratedFeatures = data.features;
                    }
                    this.handleGenerationComplete(data);
                    break;
                case 'code_generated':
                    // console.log('[WS] Code generated:', data.files?.length || 0, 'files');
                    if (data.files && data.files.length > 0) {
                        this.displayGeneratedCode(data.files, data);
                    }
                    // Update modal LLM info if it's visible
                    if (!this.successModal.classList.contains('hidden')) {
                        const llmInfo = document.getElementById('modalLLMInfo');
                        const llmProvider = document.getElementById('llmProvider');
                        if (data.generated_by_llm || data.modified_by_llm) {
                            const llmName = data.generated_by_llm || data.modified_by_llm;
                            const isModification = data.modified_by_llm ? true : false;
                            const prefix = isModification ? 'Modified by' : 'Generated by';
                            const llmDisplayNames = {
                                'anthropic': 'Claude 3.5 Sonnet',
                                'claude': 'Claude 3.5 Sonnet',
                                'openai': 'GPT-4 Turbo',
                                'gpt4': 'GPT-4 Turbo',
                                'xai': 'xAI Grok',
                                'grok': 'xAI Grok',
                                'self-healing': 'Self-Healing System',
                                'agents': 'Agent System',
                                'agent_system': 'Agent System',
                                'unknown': 'AI Assistant'
                            };
                            llmProvider.textContent = `${prefix} ${llmDisplayNames[llmName.toLowerCase()] || llmName}`;
                            llmInfo.style.display = 'flex';
                        }
                    }
                    break;
                case 'chat_response':
                    // console.log('[WS] Chat response:', data.message);
                    this.removeTypingIndicator();
                    this.addMessage('assistant', data.message);
                    break;
                case 'intelligent_status':
                    // console.log('[WS] Intelligent status:', data.message);
                    this.showIntelligentMessage(data.message, data.is_motivational);
                    break;
                default:
                    // console.log('[WS] Unknown message type:', data.type);
            }
        }

        async handleSubmit() {
            const input = this.chatInput.value.trim();
            if (!input || this.isGenerating) return;

            // Add user message
            this.addMessage('user', input);

            // Clear input
            this.chatInput.value = '';
            this.chatInput.style.height = 'auto';

            // If there's an active project, treat EVERYTHING as modification request
            // unless it's a clear command
            const isCommand = this.isCommand(input);
            
            if (isCommand) {
                // Handle commands
                this.handleCommand(input);
                return;
            }
            
            // Add typing indicator immediately for ALL requests
            this.addTypingIndicator();
            
            // Flag to track if request was handled
            let requestHandled = false;
            
            // Pre-generate project_id for generation requests
            let preGeneratedProjectId = null;
            if (this.looksLikeGeneration(input) && !this.currentProjectId) {
                preGeneratedProjectId = `proj_${Math.random().toString(36).substr(2, 8)}`;
                // console.log('[UI] Pre-generating project ID:', preGeneratedProjectId);
                
                // Connect WebSocket BEFORE API call
                this.setupWebSocket(preGeneratedProjectId);
                
                // Wait for WebSocket connection to establish
                await new Promise(resolve => setTimeout(resolve, 150));
                // console.log('[UI] WebSocket pre-connected for generation');
            }
            
            // CRITICAL FIX: Also ensure WebSocket is connected for modifications
            if (this.currentProjectId && (!this.ws || this.ws.readyState !== WebSocket.OPEN)) {
                console.log('[UI] Reconnecting WebSocket for modification');
                this.setupWebSocket(this.currentProjectId);
                await new Promise(resolve => setTimeout(resolve, 150));
            }
            
            // Try the chat endpoint first for intelligent routing
            try {
                const chatResponse = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: input,
                        project_id: this.currentProjectId || preGeneratedProjectId,
                        context: {
                            just_generated: this.lastAction === 'generated',
                            last_action: this.lastAction
                        }
                    })
                });

                if (chatResponse.ok) {
                    const chatResult = await chatResponse.json();
                    
                    // Check if it was handled as a chat
                    if (chatResult.type === 'chat') {
                        this.removeTypingIndicator();
                        this.addMessage('assistant', chatResult.response);
                        requestHandled = true;
                        return;
                    }
                    
                    // If it's a technical response with immediate acknowledgment
                    if (chatResult.type === 'technical' && chatResult.response) {
                        // Remove typing indicator and show immediate acknowledgment
                        this.removeTypingIndicator();
                        this.addMessage('assistant', chatResult.response);
                        
                        // If it's a modification, we already have the project_id
                        if (chatResult.action === 'modify' && chatResult.project_id) {
                            this.currentProjectId = chatResult.project_id;
                            
                            // CRITICAL FIX: Ensure WebSocket is connected for modifications
                            // console.log('[UI] Ensuring WebSocket connection for modification:', chatResult.project_id);
                            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                                // console.log('[UI] WebSocket not connected, setting up now...');
                                this.setupWebSocket(chatResult.project_id);
                            } else {
                                // console.log('[UI] WebSocket already connected');
                            }
                            
                            // The modification is happening in background
                            // Show status panel for progress tracking
                            this.statusPanel.classList.remove('hidden');
                            this.resetStatusStages();
                            
                            // Update progress title for modification
                            const progressTitle = document.getElementById('progressTitle');
                            if (progressTitle) {
                                progressTitle.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Modification Progress';
                            }
                            
                            // Show initial status
                            const progressText = document.getElementById('progressText');
                            if (progressText) {
                                progressText.textContent = 'Preparing modifications...';
                            }
                            
                            // Update UI state
                            this.isGenerating = true;
                            this.sendBtn.disabled = true;
                            this.sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                            
                            // Start timer for modification
                            this.startGenerationTimer();
                            
                            // WebSocket will send updates
                            requestHandled = true;
                            return;
                        }
                        
                        // If it's generation with immediate response
                        if (chatResult.action === 'generate' && chatResult.project_id) {
                            // Set up the project ID
                            this.currentProjectId = chatResult.project_id;
                            
                            // WebSocket should already be connected if we pre-generated
                            if (preGeneratedProjectId && preGeneratedProjectId === chatResult.project_id) {
                                // console.log('[UI] WebSocket already pre-connected for project:', chatResult.project_id);
                            } else {
                                // Fallback: Setup WebSocket if not pre-connected
                                // console.log('[UI] Setting up WebSocket for project:', chatResult.project_id);
                                this.setupWebSocket(chatResult.project_id);
                            }
                            
                            // Show status panel and start tracking
                            this.statusPanel.classList.remove('hidden');
                            this.resetStatusStages();
                            
                            // Show initial status immediately
                            const progressText = document.getElementById('progressText');
                            if (progressText) {
                                progressText.textContent = 'Connecting to generation service...';
                                console.log('[UI] Set initial progress text to:', progressText.textContent);
                                
                                // Force DOM update
                                progressText.style.display = 'none';
                                progressText.offsetHeight; // Trigger reflow
                                progressText.style.display = '';
                            }
                            
                            // Update UI state
                            this.isGenerating = true;
                            this.sendBtn.disabled = true;
                            this.sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                            
                            // Start timer
                            this.startGenerationTimer();
                            
                            // Update progress title
                            const progressTitle = document.getElementById('progressTitle');
                            if (progressTitle) {
                                progressTitle.innerHTML = '<i class="fas fa-tasks mr-2"></i>Generation Progress';
                            }
                            
                            // IMPORTANT: Return here to prevent duplicate API call
                            requestHandled = true;
                            return;
                        }
                    }
                    
                    // If it's a technical response (generation/modification started)
                    if (chatResult.project_id) {
                        // Continue with existing flow
                        this.currentProjectId = chatResult.project_id;
                        // Let the existing code below handle the technical flow
                    }
                }
            } catch (error) {
                console.log('Chat endpoint error:', error);
                // Don't fall through to direct API calls if we already handled the request
                if (this.currentProjectId && this.isGenerating) {
                    console.log('Already processing, not falling back to direct API');
                    return;
                }
            }

            // Fallback to existing behavior if chat endpoint fails or doesn't handle it
            // ONLY if the request wasn't already handled
            if (requestHandled) {
                console.log('Request already handled, not running fallback code');
                return;
            }
            
            if (this.currentProjectId) {
                // Skip question detection - treat as modification
            } else {
                // Only check for questions when no project is active
                const isQuestion = this.isQuestion(input);
                if (isQuestion) {
                    // Handle questions intelligently
                    this.handleQuestion(input);
                    return;
                }
            }

            // Otherwise, treat as app generation or modification request
            // Validate input
            if (!input || input.trim().length === 0) {
                this.addMessage('assistant', 'Please provide a description of what you want to create or modify.');
                return;
            }

            // Disable send button and show generating state
            this.isGenerating = true;
            this.sendBtn.disabled = true;
            this.sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

            // Show status panel
            this.statusPanel.classList.remove('hidden');
            this.resetStatusStages();
            
            // Update progress title based on action
            const progressTitle = document.getElementById('progressTitle');
            if (progressTitle) {
                const isModification = !!this.currentProjectId;
                progressTitle.innerHTML = isModification 
                    ? '<i class="fas fa-sync-alt mr-2"></i>Modification Progress'
                    : '<i class="fas fa-tasks mr-2"></i>Generation Progress';
            }
            
            // Initialize the progress text to show we're starting
            const progressText = document.getElementById('progressText');
            if (progressText) {
                progressText.textContent = 'Starting...';
                // console.log('[UI] Initialized progressText to "Starting..."');
            }
            
            // Start timer
            this.startGenerationTimer();

            // Typing indicator is already added at the start of handleSubmit
            // It will be removed when we get a response

            try {
                // Always use the /api/chat endpoint for both generation and modification
                const endpoint = '/api/chat';
                
                // For new projects, generate project ID and connect WebSocket first
                let projectId = this.currentProjectId;
                if (!projectId) {
                    projectId = `proj_${Math.random().toString(36).substr(2, 8)}`;
                    // Connect WebSocket before API call
                    this.setupWebSocket(projectId);
                    // Wait a bit for connection
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Get iOS version safely
                const iosVersionElement = document.getElementById('iosVersion');
                const iosVersion = iosVersionElement ? iosVersionElement.value : '17.0';
                
                // Use ChatRequest format for both generation and modification
                const payload = {
                    message: input,
                    project_id: this.currentProjectId || projectId,
                    context: {
                        ios_version: iosVersion,
                        is_modification: isModification
                    }
                };

                // Debug logging
                console.log('API Request:', {
                    endpoint: endpoint,
                    payload: payload,
                    currentProjectId: this.currentProjectId
                });

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log('API Response:', {
                    status: response.status,
                    ok: response.ok,
                    result: result
                });
                
                // Handle 422 validation errors specifically
                if (response.status === 422) {
                    console.error('Validation Error (422):', result);
                    let errorMessage = 'Validation error: ';
                    if (result.detail) {
                        if (Array.isArray(result.detail)) {
                            // FastAPI validation errors come as array
                            const errors = result.detail.map(err => `${err.loc.join('.')}: ${err.msg}`).join(', ');
                            errorMessage += errors;
                        } else {
                            errorMessage += result.detail;
                        }
                    } else {
                        errorMessage += 'Invalid request data';
                    }
                    throw new Error(errorMessage);
                }

                if (response.ok && result.project_id) {
                    this.currentProjectId = result.project_id;
                    
                    // Always ensure WebSocket is connected with the project ID
                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                        // console.log('[UI] Setting up WebSocket for project:', result.project_id);
                        this.setupWebSocket(result.project_id);
                        // Very short delay for connection
                        await new Promise(resolve => setTimeout(resolve, 10));
                    } else {
                        console.log('[UI] WebSocket already connected');
                    }
                    
                    this.removeTypingIndicator();

                    // Add assistant response with rich details
                    if (result.status === 'success') {
                        // Check if this is a modification or creation
                        const isModification = result.modification_summary || result.changes_made || result.modified_by_llm;
                        
                        if (isModification) {
                            // Show modification success message
                            this.lastAction = 'modified';
                            let detailMessage = `✅ I've successfully modified **${result.app_name}**!\n\n`;
                            
                            if (result.changes_made && Array.isArray(result.changes_made) && result.changes_made.length > 0) {
                                detailMessage += `📝 **Changes Applied:**\n`;
                                result.changes_made.forEach(change => {
                                    detailMessage += `• ${change}\n`;
                                });
                                detailMessage += '\n';
                            } else if (result.modification_summary) {
                                detailMessage += `📝 **Modification:** ${result.modification_summary}\n\n`;
                            }
                            
                            detailMessage += `📁 **Updated ${result.files.length} files**\n`;
                            detailMessage += `🤖 **Modified by:** ${result.modified_by_llm || 'AI'}\n`;
                            detailMessage += `\n🔨 The app is rebuilding and will relaunch in the simulator...`;
                            
                            this.addMessage('assistant', detailMessage);
                        } else {
                            // Show creation success message
                            this.lastAction = 'generated';
                            let detailMessage = `🎉 I've successfully created **${result.app_name}**!\n\n`;
                            
                            if (result.features && result.features.length > 0) {
                                detailMessage += `✨ **Features implemented:**\n`;
                                result.features.forEach(feature => {
                                    detailMessage += `• ${feature}\n`;
                                });
                                detailMessage += '\n';
                            }
                            
                            if (result.unique_aspects) {
                                detailMessage += `🎨 **What makes this unique:** ${result.unique_aspects}\n\n`;
                            }
                            
                            detailMessage += `📁 **Generated ${result.files.length} Swift files**\n`;
                            detailMessage += `🤖 **Powered by:** ${result.generated_by_llm || 'AI'}\n`;
                            
                            if (result.quality_score) {
                                detailMessage += `📊 **Quality Score:** ${result.quality_score}%\n`;
                            }
                            
                            detailMessage += `\n🔨 The app is now building and will launch in the simulator...`;
                            
                            this.addMessage('assistant', detailMessage);
                        }
                        
                        this.displayGeneratedCode(result.files, result);
                    } else if (result.files && result.files.length > 0) {
                        // Fallback for partial success
                        const fileCount = result.files.length;
                        const isModification = result.modification_summary || result.changes_made || result.modified_by_llm;
                        if (isModification) {
                            this.addMessage('assistant', `I've modified your ${result.app_name || 'iOS app'} updating ${fileCount} files. The app is rebuilding...`);
                        } else {
                            this.addMessage('assistant', `I've generated your ${result.app_name || 'iOS app'} with ${fileCount} Swift files. The app is now building...`);
                        }
                        this.displayGeneratedCode(result.files, result);
                    }
                } else {
                    throw new Error(result.detail || 'Generation failed');
                }
            } catch (error) {
                this.removeTypingIndicator();
                this.showError('Generation Failed', error.message);
                this.addMessage('assistant', `I encountered an error: ${error.message}. Please try again or modify your request.`);
            } finally {
                // This is a fallback, but should be handled by complete/error handlers
                if (this.isGenerating) {
                    this.isGenerating = false;
                    this.sendBtn.disabled = false;
                    this.sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                }
            }
        }

        addMessage(type, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';

            if (type === 'user') {
                messageDiv.innerHTML = `
                        <div class="flex items-start space-x-3 justify-end">
                            <div class="max-w-md">
                                <div class="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-4 py-2 rounded-xl rounded-tr-none">
                                    <p class="text-sm">${this.escapeHtml(content)}</p>
                                </div>
                            </div>
                            <div class="w-8 h-8 bg-gray-700 rounded-full flex items-center justify-center flex-shrink-0">
                                <i class="fas fa-user text-gray-400 text-sm"></i>
                            </div>
                        </div>
                    `;
            } else {
                // Format content with basic markdown support
                const formattedContent = this.formatMarkdown(content);
                
                messageDiv.innerHTML = `
                        <div class="flex items-start space-x-3">
                            <div class="w-8 h-8 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center flex-shrink-0">
                                <i class="fas fa-robot text-white text-sm"></i>
                            </div>
                            <div class="flex-1 max-w-md">
                                <div class="bg-gray-800 px-4 py-2 rounded-xl rounded-tl-none">
                                    <div class="text-sm text-gray-300 space-y-2">${formattedContent}</div>
                                </div>
                            </div>
                        </div>
                    `;
            }

            this.chatMessages.appendChild(messageDiv);
            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
        }

        addTypingIndicator() {
            const indicatorDiv = document.createElement('div');
            indicatorDiv.id = 'typingIndicator';
            indicatorDiv.className = 'chat-message';
            indicatorDiv.innerHTML = `
                    <div class="flex items-start space-x-3">
                        <div class="w-8 h-8 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center flex-shrink-0">
                            <i class="fas fa-robot text-white text-sm"></i>
                        </div>
                        <div class="bg-gray-800 px-4 py-3 rounded-xl rounded-tl-none">
                            <div class="typing-indicator">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                    </div>
                `;
            this.chatMessages.appendChild(indicatorDiv);
            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
        }

        removeTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (indicator) {
                indicator.remove();
            }
        }
        
        showIntelligentMessage(message, isMotivational = false) {
            // Create the intelligent message element
            const messageDiv = document.createElement('div');
            messageDiv.className = `intelligent-message ${isMotivational ? 'motivational' : ''}`;
            
            // Calculate reading time (200 words per minute)
            const words = message.split(' ').length;
            const readTime = Math.max(3000, Math.min(8000, words * 300)); // 3-8 seconds
            
            messageDiv.innerHTML = `
                <button class="close-btn" onclick="this.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </button>
                <p class="message-content">${message}</p>
            `;
            
            // Add to body
            document.body.appendChild(messageDiv);
            
            // Auto-remove after reading time
            setTimeout(() => {
                messageDiv.style.animation = 'fadeOut 0.5s ease-out';
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, 500);
            }, readTime);
            
            // If there are multiple messages, stack them
            const existingMessages = document.querySelectorAll('.intelligent-message');
            if (existingMessages.length > 1) {
                let topOffset = 80;
                existingMessages.forEach((msg, index) => {
                    if (msg !== messageDiv) {
                        topOffset += (msg.offsetHeight + 15);
                    }
                });
                messageDiv.style.top = `${topOffset}px`;
            }
        }
        
        getStatusIcon(status) {
            const statusIcons = {
                'initializing': 'fas fa-circle-notch fa-spin text-gray-500',
                'analyzing': 'fas fa-circle-notch fa-spin text-blue-500',
                'generating': 'fas fa-circle-notch fa-spin text-purple-500',
                'validating': 'fas fa-circle-notch fa-spin text-yellow-500',
                'healing': 'fas fa-circle-notch fa-spin text-orange-500',
                'creating': 'fas fa-circle-notch fa-spin text-green-500',
                'building': 'fas fa-circle-notch fa-spin text-indigo-500',
                'success': 'fas fa-check-circle text-green-500',
                'failed': 'fas fa-times-circle text-red-500'
            };
            
            return statusIcons[status] || 'fas fa-circle-notch fa-spin text-gray-500';
        }

        updateStatus(message, status) {
            // console.log('[UI] updateStatus called:', { message, status, timestamp: new Date().toISOString() });
            
            // Update the prominent status message
            const progressText = document.getElementById('progressText');
            if (progressText) {
                // console.log('[UI] Updating progressText with:', message);
                // console.log('[UI] progressText before update:', progressText.textContent);
                progressText.textContent = message;
                // console.log('[UI] progressText after update:', progressText.textContent);
                
                // Force DOM update to ensure visibility
                progressText.style.display = 'none';
                progressText.offsetHeight; // Trigger reflow
                progressText.style.display = '';
            } else {
                console.error('[UI] progressText element not found!');
                // Try to find it again in case it was added dynamically
                setTimeout(() => {
                    const retryProgressText = document.getElementById('progressText');
                    if (retryProgressText) {
                        // console.log('[UI] Found progressText on retry');
                        retryProgressText.textContent = message;
                    }
                }, 100);
            }
            
            const currentStatusMessage = document.querySelector('#currentStatusMessage p');
            if (currentStatusMessage) {
                
                // Update icon based on status
                const icon = currentStatusMessage.querySelector('i');
                if (icon) {
                    icon.className = 'mr-2 text-xs';
                    
                    const statusIcons = {
                        'analyzing': 'fas fa-search fa-spin text-blue-400',
                        'generating': 'fas fa-code fa-spin text-purple-400',
                        'validating': 'fas fa-check-circle fa-spin text-yellow-400',
                        'healing': 'fas fa-magic fa-spin text-orange-400',
                        'creating': 'fas fa-folder-plus fa-spin text-green-400',
                        'building': 'fas fa-hammer fa-spin text-indigo-400',
                        'success': 'fas fa-check-circle text-green-400',
                        'failed': 'fas fa-exclamation-circle text-red-400'
                    };
                    
                    if (statusIcons[status]) {
                        icon.className = statusIcons[status] + ' mr-2';
                    } else {
                        icon.className = 'fas fa-circle-notch fa-spin text-gray-400 mr-2';
                    }
                }
            }
            
            // IMPORTANT: Show key status updates in chat for visibility, but keep it clean
            // Remove typing indicator first
            this.removeTypingIndicator();
            
            // Track last status to avoid duplicate updates
            if (!this.lastStatusShown) {
                this.lastStatusShown = { status: '', message: '', timestamp: 0 };
            }
            
            // Show ALL progress updates during critical phases to keep user informed
            const importantStatuses = {
                'initializing': true,
                'analyzing': true, 
                'generating': true,
                'validating': true,
                'creating': true,
                'building': true,
                'success': true,
                'failed': true,
                'error': true
            };
            
            // Always show different messages or after short intervals during building
            const now = Date.now();
            const timeSinceLastStatus = now - this.lastStatusShown.timestamp;
            const isDifferentStatus = status !== this.lastStatusShown.status;
            const isDifferentMessage = message !== this.lastStatusShown.message;
            const isImportantStatus = importantStatuses[status];
            const isFinalMessage = message.includes('✅') || message.includes('❌');
            const isBuildingPhase = status === 'building' || message.includes('Building') || message.includes('Compiling');
            
            // CRITICAL: Show all updates during building and important phases
            // console.log('[UI] Status check:', { 
            //     isImportantStatus, 
            //     isFinalMessage, 
            //     isBuildingPhase,
            //     status, 
            //     timeSinceLastStatus,
            //     isDifferentStatus,
            //     isDifferentMessage
            // });
            
            // Status is now only shown in the dedicated status panel, not in chat
            // This prevents duplicate status messages
            if (isImportantStatus || isFinalMessage || isBuildingPhase || isDifferentStatus || isDifferentMessage || timeSinceLastStatus > 300) {
                this.lastStatusShown = { status, message, timestamp: now };
                // console.log('[UI] Status panel updated, chat updates disabled to prevent duplicates');
            }
            
            // Add to detailed status with color coding
            const statusLine = document.createElement('div');
            const statusColors = {
                'analyzing': 'text-blue-400',
                'generating': 'text-purple-400',
                'validating': 'text-yellow-400',
                'healing': 'text-orange-400',
                'creating': 'text-green-400',
                'building': 'text-indigo-400',
                'success': 'text-green-400',
                'failed': 'text-red-400'
            };
            
            statusLine.className = statusColors[status] || 'text-gray-400';
            statusLine.innerHTML = `<span class="text-gray-500">[${new Date().toLocaleTimeString()}]</span> ${message}`;
            this.statusDetails.appendChild(statusLine);

            // Keep only last 10 messages
            while (this.statusDetails.children.length > 10) {
                this.statusDetails.removeChild(this.statusDetails.firstChild);
            }

            // Auto-scroll to bottom
            this.statusDetails.scrollTop = this.statusDetails.scrollHeight;
            
            // CRITICAL: Make sure status panel is visible
            if (this.statusPanel && this.statusPanel.classList.contains('hidden')) {
                this.statusPanel.classList.remove('hidden');
            }
            
            // Auto-show details panel when receiving updates
            if (this.detailsPanel && this.detailsPanel.classList.contains('hidden')) {
                this.detailsPanel.classList.remove('hidden');
                const icon = this.toggleDetails.querySelector('i');
                if (icon) {
                    icon.classList.remove('fa-chevron-down');
                    icon.classList.add('fa-chevron-up');
                }
            }
            
            // Update the main status text based on the message
            const mainStatusText = document.querySelector('#generationStatus p');
            if (mainStatusText) {
                mainStatusText.textContent = message;
                
                // Add a pulse effect to draw attention
                mainStatusText.classList.add('animate-pulse');
                setTimeout(() => mainStatusText.classList.remove('animate-pulse'), 1000);
            }
            
            // Also update in the stages section
            const currentStageText = document.querySelector('.progress-stage.active + p');
            if (currentStageText) {
                currentStageText.textContent = message.substring(0, 30) + '...';
            }
        }

        updateStatusStage(stage, status) {
            const stageElement = document.getElementById(`stage-${stage}`);
            if (!stageElement) return;

            // Remove all status classes
            stageElement.classList.remove('active', 'complete', 'error');

            // Add appropriate class
            if (status === 'active') {
                stageElement.classList.add('active', 'pulse-animation');
                const svg = stageElement.querySelector('svg');
                svg.classList.remove('text-gray-600', 'text-green-400', 'text-red-400');
                svg.classList.add('text-blue-400');
            } else if (status === 'complete') {
                stageElement.classList.remove('pulse-animation');
                stageElement.classList.add('complete');
                const svg = stageElement.querySelector('svg');
                svg.classList.remove('text-gray-600', 'text-blue-400', 'text-red-400');
                svg.classList.add('text-green-400');
            } else if (status === 'error') {
                stageElement.classList.remove('pulse-animation');
                stageElement.classList.add('error');
                const svg = stageElement.querySelector('svg');
                svg.classList.remove('text-gray-600', 'text-blue-400', 'text-green-400');
                svg.classList.add('text-red-400');
            }
        }

        resetStatusStages() {
            const stages = ['design', 'implement', 'validate', 'build', 'fix', 'launch'];
            stages.forEach(stage => {
                const element = document.getElementById(`stage-${stage}`);
                if (element) {
                    element.classList.remove('active', 'complete', 'error', 'pulse-animation');
                    const svg = element.querySelector('svg');
                    svg.classList.remove('text-blue-400', 'text-green-400', 'text-red-400');
                    svg.classList.add('text-gray-600');
                }
            });

            // Clear status details
            this.statusDetails.innerHTML = '';
            this.errorSection.classList.add('hidden');
            this.errorList.innerHTML = '';
        }
        
        startGenerationTimer() {
            this.generationStartTime = Date.now();
            this.timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - this.generationStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timerDisplay = document.getElementById('timerDisplay');
                if (timerDisplay) {
                    timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }
        
        stopGenerationTimer() {
            if (this.timerInterval) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }
        }

        showError(title, details) {
            // CRITICAL: Reset generating state on error
            this.isGenerating = false;
            
            // Stop timer
            this.stopGenerationTimer();
            
            // Hide progress animation
            const progressElement = document.querySelector('.animate-pulse');
            if (progressElement) {
                progressElement.remove();
            }
            
            this.errorSection.classList.remove('hidden');
            this.errorList.innerHTML = '';

            if (Array.isArray(details)) {
                details.forEach(error => {
                    const errorItem = document.createElement('div');
                    errorItem.className = 'text-sm';
                    errorItem.textContent = error;
                    this.errorList.appendChild(errorItem);
                });
            } else {
                const errorItem = document.createElement('div');
                errorItem.className = 'text-sm';
                errorItem.textContent = details || title;
                this.errorList.appendChild(errorItem);
            }

            // Update the last stage with error
            const stages = ['design', 'implement', 'validate', 'build', 'fix', 'launch'];
            for (let i = stages.length - 1; i >= 0; i--) {
                const element = document.getElementById(`stage-${stages[i]}`);
                if (element.classList.contains('active') || element.classList.contains('complete')) {
                    this.updateStatusStage(stages[i], 'error');
                    break;
                }
            }
            
            // Enable the chat input for retry
            this.chatInput.disabled = false;
            this.sendBtn.disabled = false;
            this.sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
        }

        handleGenerationComplete(data) {
            // console.log('[UI] handleGenerationComplete called with:', data);
            
            // CRITICAL: Reset generating state to allow new messages
            this.isGenerating = false;
            
            // Stop timer
            this.stopGenerationTimer();
            
            // Remove typing indicator if present
            this.removeTypingIndicator();
            
            // Remove the status line container to keep chat clean
            const statusLineContainer = document.getElementById('currentStatusLineContainer');
            if (statusLineContainer) {
                statusLineContainer.remove();
            }
            
            // Hide progress animation
            const progressElement = document.querySelector('.animate-pulse');
            if (progressElement) {
                progressElement.remove();
            }
            
            // Check for success (backend sends status: "success", not success: true)
            if (data.status === 'success') {
                // Update modal based on whether this is creation or modification
                const isModification = data.modification_summary || data.changes_made;
                const modalTitle = document.getElementById('modalTitle');
                const modalSubtitle = document.getElementById('modalSubtitle');
                
                if (isModification) {
                    modalTitle.textContent = 'App Modified Successfully!';
                    modalSubtitle.textContent = 'Your changes have been applied and the app is running';
                } else {
                    modalTitle.textContent = 'App Created Successfully!';
                    modalSubtitle.textContent = 'Your app is now running in the iOS Simulator';
                }
                
                // Update LLM provider info
                const llmInfo = document.getElementById('modalLLMInfo');
                const llmProvider = document.getElementById('llmProvider');
                if (data.generated_by_llm || data.modified_by_llm) {
                    const llmName = data.generated_by_llm || data.modified_by_llm;
                    const prefix = isModification ? 'Modified by' : 'Generated by';
                    // Map provider names to display names
                    const llmDisplayNames = {
                        'anthropic': 'Claude 3.5 Sonnet',
                        'claude': 'Claude 3.5 Sonnet',
                        'openai': 'GPT-4 Turbo',
                        'gpt4': 'GPT-4 Turbo',
                        'xai': 'xAI Grok',
                        'grok': 'xAI Grok',
                        'self-healing': 'Self-Healing System',
                        'agents': 'Agent System',
                        'agent_system': 'Agent System',
                        'unknown': 'AI Assistant'
                    };
                    llmProvider.textContent = `${prefix} ${llmDisplayNames[llmName.toLowerCase()] || llmName}`;
                    llmInfo.style.display = 'flex';  // Changed from 'block' to 'flex' to match CSS
                    
                    // Debug logging
                    console.log('LLM Info Updated:', {
                        llmName: llmName,
                        prefix: prefix,
                        display: llmInfo.style.display
                    });
                } else {
                    // If no LLM info, show a default
                    llmProvider.textContent = `${isModification ? 'Modified by' : 'Generated by'} SwiftGen AI`;
                    llmInfo.style.display = 'flex';
                }
                
                // Show success modal
                this.successModal.classList.remove('hidden');

                // Update final message - use the actual message from backend which includes simulator status
                if (data.message) {
                    this.addMessage('assistant', data.message);
                } else {
                    // Fallback message if backend doesn't send one
                    const defaultMessage = data.simulator_launched 
                        ? '🎉 Your app is now running in the iOS Simulator! You can continue to request modifications or create a new app.'
                        : '✅ Your app has been built successfully! Please launch it manually in the iOS Simulator. You can continue to request modifications or create a new app.';
                    this.addMessage('assistant', defaultMessage);
                }
                
                // Show simplified next steps if provided
                if (data.next_steps) {
                    this.addMessage('assistant', data.next_steps);
                }

                // Update all stages to complete
                const stages = ['design', 'implement', 'validate', 'build', 'fix', 'launch'];
                stages.forEach(stage => {
                    this.updateStatusStage(stage, 'complete');
                });

                // Add success status based on whether simulator actually launched
                let statusMessage;
                if (data.simulator_launched) {
                    statusMessage = isModification 
                        ? '✅ Modifications applied and app relaunched!' 
                        : '✅ App launched successfully in iOS Simulator!';
                } else {
                    statusMessage = isModification 
                        ? '✅ Modifications applied! Please launch the app manually in the simulator.' 
                        : '✅ App built successfully! Please launch the app manually in the simulator.';
                }
                this.updateStatus(statusMessage, 'success');
                
                // Enable the chat input for modifications
                this.chatInput.disabled = false;
                this.sendBtn.disabled = false;
                this.sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
            } else {
                // Failed status
                const errorMessage = data.errors && data.errors.length > 0 
                    ? `❌ The build encountered these errors:\n${data.errors.slice(0, 3).join('\n')}\n\nI can help fix these! Just tell me what you'd like to change.`
                    : '❌ The app build failed. I can help you fix the issues. Please describe what you\'d like me to correct.';
                    
                this.addMessage('assistant', errorMessage);
                
                // Still enable input for retries
                this.chatInput.disabled = false;
                this.sendBtn.disabled = false;
                this.sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                this.isGenerating = false;
            }
        }

        displayGeneratedCode(files, data = {}) {
            const codeDisplay = document.getElementById('codeDisplay');
            const noCodeMessage = document.getElementById('noCodeMessage');
            const fileTabs = document.getElementById('fileTabs');
            const fileTabsContainer = document.getElementById('fileTabsContainer');

            // CRITICAL: Validate files have content
            const validFiles = files.filter(file => {
                if (!file.content || !file.content.trim()) {
                    console.error(`File ${file.path} has no content!`);
                    return false;
                }
                return true;
            });

            if (validFiles.length === 0) {
                console.error('No valid files with content found');
                this.addMessage('assistant', '⚠️ Warning: No valid code files were generated. This might be a generation error. Please try again.');
                return;
            }

            // Store files for later use
            this.generatedFiles = validFiles;

            // Show code display
            codeDisplay.classList.remove('hidden');
            noCodeMessage.classList.add('hidden');
            fileTabs.classList.remove('hidden');
            this.codeActions.classList.remove('hidden');

            // Clear previous tabs
            fileTabsContainer.innerHTML = '';

            // Create tab container
            const tabContainer = document.createElement('div');
            tabContainer.className = 'flex items-center space-x-1';

            // Create file tabs
            validFiles.forEach((file, index) => {
                const fileName = file.path.split('/').pop();
                const tab = document.createElement('button');
                tab.className = `px-3 py-1.5 text-sm font-medium transition-all rounded-t-lg ${
                    index === 0
                        ? 'text-blue-400 bg-gray-900 border-b-2 border-blue-400'
                        : 'text-gray-400 hover:text-gray-200 hover:bg-gray-800'
                }`;
                tab.textContent = fileName;
                tab.onclick = () => this.selectFile(index);
                tab.setAttribute('data-file-index', index);
                tabContainer.appendChild(tab);
            });

            // Add LLM provider info if available
            if (data.generated_by_llm || data.modified_by_llm) {
                const llmName = data.generated_by_llm || data.modified_by_llm;
                const prefix = data.modified_by_llm ? 'Modified by' : 'Generated by';
                // Map provider names to display names
                const llmDisplayNames = {
                    'anthropic': 'Claude 3.5 Sonnet',
                    'claude': 'Claude 3.5 Sonnet',
                    'openai': 'GPT-4 Turbo',
                    'gpt4': 'GPT-4 Turbo',
                    'xai': 'xAI Grok',
                    'grok': 'xAI Grok',
                    'self-healing': 'Self-Healing System',
                    'agents': 'Agent System',
                    'unknown': 'AI Assistant'
                };
                
                const llmInfo = document.createElement('div');
                llmInfo.className = 'text-xs text-gray-500 italic';
                llmInfo.textContent = `${prefix} ${llmDisplayNames[llmName.toLowerCase()] || llmName}`;
                tabContainer.appendChild(llmInfo);
            }

            fileTabsContainer.appendChild(tabContainer);

            // Display first file
            if (validFiles.length > 0) {
                this.selectFile(0);
            }
        }

        selectFile(index) {
            const tabs = document.querySelectorAll('#fileTabsContainer button[data-file-index]');
            const codeContent = document.getElementById('codeContent');

            tabs.forEach((tab, i) => {
                if (i === index) {
                    tab.className = 'px-3 py-1.5 text-sm font-medium transition-all rounded-t-lg text-blue-400 bg-gray-900 border-b-2 border-blue-400';
                } else {
                    tab.className = 'px-3 py-1.5 text-sm font-medium transition-all rounded-t-lg text-gray-400 hover:text-gray-200 hover:bg-gray-800';
                }
            });

            const file = this.generatedFiles[index];

            if (!file || !file.content) {
                console.error(`File at index ${index} has no content`);
                codeContent.innerHTML = '<span class="text-red-400">// Error: No content available for this file</span>';
                return;
            }

            // Apply syntax highlighting
            codeContent.textContent = file.content;
            Prism.highlightElement(codeContent);
            this.currentFileIndex = index;
        }

        copyCurrentCode() {
            const file = this.generatedFiles[this.currentFileIndex];
            if (file && file.content) {
                navigator.clipboard.writeText(file.content).then(() => {
                    const copyBtn = document.getElementById('copyCode');
                    const originalText = copyBtn.innerHTML;
                    copyBtn.innerHTML = '<i class="fas fa-check mr-1"></i>Copied!';
                    setTimeout(() => {
                        copyBtn.innerHTML = originalText;
                    }, 2000);
                });
            }
        }

        downloadCurrentCode() {
            const file = this.generatedFiles[this.currentFileIndex];
            if (file && file.content) {
                const blob = new Blob([file.content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.path.split('/').pop();
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        formatMarkdown(text) {
            // Basic markdown formatting
            let formatted = this.escapeHtml(text);
            
            // Split by newlines to handle paragraphs
            const lines = formatted.split('\n');
            const formattedLines = [];
            
            lines.forEach(line => {
                // Bold text
                line = line.replace(/\*\*(.+?)\*\*/g, '<strong class="font-semibold text-gray-100">$1</strong>');
                
                // Bullet points
                if (line.trim().startsWith('•')) {
                    line = `<li class="ml-4">${line.trim().substring(1).trim()}</li>`;
                }
                
                // Headers (lines ending with :)
                if (line.endsWith(':') && !line.includes('**')) {
                    line = `<span class="font-semibold text-gray-100">${line}</span>`;
                }
                
                formattedLines.push(line);
            });
            
            // Join lines and wrap bullet lists
            let result = formattedLines.join('<br>');
            
            // Wrap consecutive <li> elements in <ul>
            result = result.replace(/(<li.*?<\/li>)(<br><li)/g, '$1$2');
            result = result.replace(/(<li.*?<\/li>)+/g, '<ul class="list-none space-y-1">$&</ul>');
            
            return result;
        }

        isQuestion(input) {
            const questionPatterns = [
                /^(what|where|when|why|who|how|can|could|would|should|is|are|do|does|did)\s/i,
                /\?$/,
                /tell me about/i,
                /explain/i,
                /help/i,
                /status/i,
                /progress/i,
                /example/i,
                /ideas/i,
                /how long/i,
                /features/i
            ];
            
            // Check if it's NOT an app creation request
            const creationPatterns = [
                /^(create|build|make|develop|generate)\s+(a|an|my)?\s*\w+\s*(app|application)/i,
                /^(i want|i need|i'd like)\s+(a|an|to build|to create)/i,
                /^(app|application)\s+\w+/i
            ];
            
            const isCreationRequest = creationPatterns.some(pattern => pattern.test(input));
            const hasQuestionPattern = questionPatterns.some(pattern => pattern.test(input));
            
            // It's a question if it has question patterns AND is not a creation request
            return hasQuestionPattern && !isCreationRequest;
        }

        isCommand(input) {
            const commandPatterns = [
                /^(show|display|list|check|test|run|debug|clear|reset|stop|cancel)/i,
                /^\/\w+/  // Slash commands
            ];
            return commandPatterns.some(pattern => pattern.test(input));
        }

        looksLikeGeneration(input) {
            const lowercaseInput = input.toLowerCase();
            const keywords = ['create', 'build', 'make', 'generate', 'develop'];
            const appKeywords = ['app', 'application'];
            
            // Check if it contains generation keywords AND app-related words
            const hasGenerationKeyword = keywords.some(kw => lowercaseInput.includes(kw));
            const hasAppKeyword = appKeywords.some(kw => lowercaseInput.includes(kw));
            
            // Also check for patterns like "I want a timer app"
            const wantPatterns = [
                /i\s+(want|need|would like)\s+(a|an|to build|to create)/i,
                /^(app|application)\s+\w+/i
            ];
            const hasWantPattern = wantPatterns.some(pattern => pattern.test(input));
            
            return (hasGenerationKeyword && hasAppKeyword) || hasWantPattern;
        }

        handleQuestion(input) {
            const lowerInput = input.toLowerCase();
            let response = '';

            // Context-aware responses based on current state
            if (lowerInput.includes('status') || lowerInput.includes('progress')) {
                if (this.isGenerating) {
                    const currentStage = document.querySelector('.progress-stage.active');
                    const stageName = currentStage ? currentStage.nextElementSibling.textContent : 'Processing';
                    response = `🔄 I'm currently in the **${stageName}** stage of creating your app. The process typically takes 30-60 seconds. I'll notify you as soon as it's ready!`;
                } else if (this.currentProjectId && this.generatedFiles.length > 0) {
                    const context = project_contexts[this.currentProjectId] || {};
                    response = `✅ Your **${context.app_name || 'app'}** is ready and running! It has ${this.generatedFiles.length} Swift files. You can:
• Ask me to modify it (e.g., "add dark mode")
• Create a new feature (e.g., "add a settings screen")
• Start fresh with /reset`;
                } else {
                    response = "🚀 I'm ready to create an amazing iOS app for you! Just describe what you'd like to build.";
                }
            } else if (lowerInput.includes('help')) {
                response = `🎯 **Here's how I can help you:**

**Creating Apps:**
• Simple: "Create a todo list app"
• Complex: "Build a social media app with posts and comments"
• Specific: "Make a fitness tracker with workout logging"

**Modifying Apps:**
• UI: "Change the color scheme to purple"
• Features: "Add user authentication"
• Fixes: "Make the buttons larger"

**Commands:**
• /status - Check current app status
• /reset - Start fresh
• /clear - Clear chat history

**Tips:** Be specific about features you want, and I'll create something unique!`;
            } else if (lowerInput.includes('can you') || lowerInput.includes('could you')) {
                // More specific capability responses
                if (lowerInput.includes('game')) {
                    response = "🎮 Yes! I can create games using SpriteKit or SwiftUI, including puzzle games, casual games, and simple arcade-style games. What type of game interests you?";
                } else if (lowerInput.includes('database') || lowerInput.includes('data')) {
                    response = "💾 Absolutely! I can create apps with Core Data for local storage, or integrate with CloudKit for cloud sync. I can also add SQLite or Realm if needed.";
                } else if (lowerInput.includes('api') || lowerInput.includes('backend')) {
                    response = "🌐 Yes! I can create apps that connect to REST APIs, handle JSON parsing, implement authentication, and manage network requests with proper error handling.";
                } else {
                    response = "✨ Yes! I specialize in creating iOS apps with SwiftUI and UIKit. I can build anything from simple utilities to complex multi-screen applications. What would you like me to create?";
                }
            } else if (lowerInput.includes('what') && (lowerInput.includes('features') || lowerInput.includes('include'))) {
                if (this.currentProjectId && this.generatedFiles.length > 0) {
                    // Show current app features
                    const features = window.lastGeneratedFeatures || ['Modern UI', 'Responsive design', 'Error handling'];
                    response = `📋 **Your current app includes:**\n${features.map(f => `• ${f}`).join('\n')}\n\nWould you like me to add any specific features?`;
                } else {
                    response = `🛠️ **I automatically include these in every app:**
• Clean, modern SwiftUI interface
• Proper error handling
• Responsive design for all iPhone sizes
• Organized code structure (MVVM)
• Comments and documentation

Just tell me your app idea, and I'll add relevant features!`;
                }
            } else if (lowerInput.includes('how long')) {
                response = "⏱️ App generation typically takes **30-60 seconds**, depending on complexity. Simple apps are faster, while apps with many features may take a bit longer. I'll keep you updated throughout the process!";
            } else if (lowerInput.includes('modify') || lowerInput.includes('change') || lowerInput.includes('update')) {
                if (this.currentProjectId) {
                    response = `🔧 I can modify your app! Here are some examples:
• "Add a dark mode toggle"
• "Change the main color to blue"
• "Add a settings screen"
• "Make the text larger"
• "Add animation to the buttons"

What would you like to change?`;
                } else {
                    response = "🤔 I don't see an active app to modify. Would you like me to create a new app first?";
                }
            } else if (lowerInput.includes('example') || lowerInput.includes('ideas')) {
                response = `💡 **Here are some popular app ideas:**

**Productivity:**
• Task manager with categories
• Habit tracker with streaks
• Pomodoro timer

**Lifestyle:**
• Recipe organizer
• Workout tracker
• Meditation timer

**Utilities:**
• Calculator with history
• Unit converter
• Password generator

**Entertainment:**
• Quiz game
• Drawing pad
• Music player

Which type interests you?`;
            } else {
                // Default but still intelligent response
                response = "💬 I'm SwiftGen AI, your iOS app creation assistant. I can build custom apps based on your description. Just tell me what kind of app you envision, and I'll bring it to life with clean Swift code!";
            }

            // Store features for context if available
            if (this.currentProjectId && window.lastGeneratedFeatures) {
                project_contexts[this.currentProjectId] = {
                    ...project_contexts[this.currentProjectId],
                    features: window.lastGeneratedFeatures
                };
            }

            this.addMessage('assistant', response);
        }

        handleCommand(input) {
            const lowerInput = input.toLowerCase();
            let response = '';

            if (lowerInput.startsWith('/clear')) {
                this.chatMessages.innerHTML = '';
                response = "Chat cleared. Ready for a new conversation!";
            } else if (lowerInput.startsWith('/reset')) {
                this.currentProjectId = null;
                this.chatMessages.innerHTML = '';
                this.statusPanel.classList.add('hidden');
                response = "Session reset. Let's create a new app!";
            } else if (lowerInput.startsWith('/status')) {
                if (this.currentProjectId) {
                    response = `Current project: ${this.currentProjectId}\nStatus: ${this.isGenerating ? 'Generating' : 'Ready'}`;
                } else {
                    response = "No active project. Start by describing an app!";
                }
            } else {
                response = `Unknown command: ${input}. Available commands: /clear, /reset, /status`;
            }

            this.addMessage('assistant', response);
        }
    }

    // Initialize app when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        new SwiftGenApp();
    });
</script>
</body>
</html>